/**
 * Dkron REST API
 * You can communicate with Dkron using a RESTful JSON API over HTTP. Dkron nodes usually listen on port `8080` for API requests. All examples in this section assume that you've found a running leader at `localhost:8080`.  Dkron implements a RESTful JSON API over HTTP to communicate with software clients. Dkron listens in port `8080` by default. All examples in this section assume that you're using the default port.  Default API responses are unformatted JSON add the `pretty=true` param to format the response.
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest from "request";

let defaultBasePath = "http://localhost:8080/v1";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
  "string",
  "boolean",
  "double",
  "integer",
  "long",
  "float",
  "number",
  "any",
];

class ObjectSerializer {
  public static findCorrectType(data: any, expectedType: string) {
    if (data == undefined) {
      return expectedType;
    } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
      return expectedType;
    } else if (expectedType === "Date") {
      return expectedType;
    } else {
      if (enumsMap[expectedType]) {
        return expectedType;
      }

      if (!typeMap[expectedType]) {
        return expectedType; // w/e we don't know the type
      }

      // Check the discriminator
      let discriminatorProperty = typeMap[expectedType].discriminator;
      if (discriminatorProperty == null) {
        return expectedType; // the type does not have a discriminator. use it.
      } else {
        if (data[discriminatorProperty]) {
          return data[discriminatorProperty]; // use the type given in the discriminator
        } else {
          return expectedType; // discriminator was not present (or an empty string)
        }
      }
    }
  }

  public static serialize(data: any, type: string) {
    if (data == undefined) {
      return data;
    } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
      return data;
    } else if (type.lastIndexOf("Array<", 0) === 0) {
      // string.startsWith pre es6
      let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
      subType = subType.substring(0, subType.length - 1); // Type> => Type
      let transformedData: any[] = [];
      for (let index in data) {
        let date = data[index];
        transformedData.push(ObjectSerializer.serialize(date, subType));
      }
      return transformedData;
    } else if (type === "Date") {
      return data.toString();
    } else {
      if (enumsMap[type]) {
        return data;
      }
      if (!typeMap[type]) {
        // in case we dont know the type
        return data;
      }

      // get the map for the correct type.
      let attributeTypes = typeMap[type].getAttributeTypeMap();
      let instance: { [index: string]: any } = {};
      for (let index in attributeTypes) {
        let attributeType = attributeTypes[index];
        instance[attributeType.baseName] = ObjectSerializer.serialize(
          data[attributeType.name],
          attributeType.type
        );
      }
      return instance;
    }
  }

  public static deserialize(data: any, type: string) {
    // polymorphism may change the actual type.
    type = ObjectSerializer.findCorrectType(data, type);
    if (data == undefined) {
      return data;
    } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
      return data;
    } else if (type.lastIndexOf("Array<", 0) === 0) {
      // string.startsWith pre es6
      let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
      subType = subType.substring(0, subType.length - 1); // Type> => Type
      let transformedData: any[] = [];
      for (let index in data) {
        let date = data[index];
        transformedData.push(ObjectSerializer.deserialize(date, subType));
      }
      return transformedData;
    } else if (type === "Date") {
      return new Date(data);
    } else {
      if (enumsMap[type]) {
        // is Enum
        return data;
      }

      if (!typeMap[type]) {
        // dont know the type
        return data;
      }
      let instance = new typeMap[type]();
      let attributeTypes = typeMap[type].getAttributeTypeMap();
      for (let index in attributeTypes) {
        let attributeType = attributeTypes[index];
        instance[attributeType.name] = ObjectSerializer.deserialize(
          data[attributeType.baseName],
          attributeType.type
        );
      }
      return instance;
    }
  }
}

/**
 * An execution represents a timed job run.
 */
export class Execution {
  /**
   * job name
   */
  "jobName"?: string;
  /**
   * start time of the execution
   */
  "startedAt"?: Date;
  /**
   * when the execution finished running
   */
  "finishedAt"?: Date;
  /**
   * the execution run successfuly
   */
  "success"?: boolean;
  /**
   * partial output of the command execution
   */
  "output"?: string;
  /**
   * name of the node that executed the command
   */
  "nodeName"?: string;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "jobName",
      baseName: "job_name",
      type: "string",
    },
    {
      name: "startedAt",
      baseName: "started_at",
      type: "Date",
    },
    {
      name: "finishedAt",
      baseName: "finished_at",
      type: "Date",
    },
    {
      name: "success",
      baseName: "success",
      type: "boolean",
    },
    {
      name: "output",
      baseName: "output",
      type: "string",
    },
    {
      name: "nodeName",
      baseName: "node_name",
      type: "string",
    },
  ];

  static getAttributeTypeMap() {
    return Execution.attributeTypeMap;
  }
}

/**
 * Executor plugin parameters
 */
export class ExecutorConfig extends null<String, string> {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return super.getAttributeTypeMap().concat(ExecutorConfig.attributeTypeMap);
  }
}

/**
 * A Job represents a scheduled task to execute.
 */
export class Job {
  /**
   * Name for the job.
   */
  "name": string;
  /**
   * Cron expression for the job.
   */
  "schedule": string;
  /**
   * Timezone where the job will be executed. By default and when field is set to empty string, the job will run in local time.
   */
  "timezone"?: string;
  /**
   * Owner of the job
   */
  "owner"?: string;
  /**
   * Email of the owner
   */
  "ownerEmail"?: string;
  /**
   * Number of successful executions
   */
  "successCount"?: number;
  /**
   * Number of failed executions
   */
  "errorCount"?: number;
  /**
   * Last time this job executed successfully
   */
  "lastSuccess"?: Date;
  /**
   * Last time this job failed
   */
  "lastError"?: Date;
  /**
   * Disabled state of the job
   */
  "disabled"?: boolean;
  /**
   * Target nodes tags of this job
   */
  "tags"?: { [key: string]: string };
  /**
   * Number of times to retry a failed job execution
   */
  "retries"?: number;
  /**
   * The name/id of the job that will trigger the execution of this job
   */
  "parentJob"?: string;
  /**
   * Array containing the jobs that depends on this one
   */
  "dependentJobs"?: Array<string>;
  "processors"?: Processors;
  /**
   * Concurrency policy for the job allow/forbid
   */
  "concurrency"?: string;
  /**
   * Executor plugin used to run the job
   */
  "executor"?: string;
  "executorConfig"?: ExecutorConfig;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "name",
      type: "string",
    },
    {
      name: "schedule",
      baseName: "schedule",
      type: "string",
    },
    {
      name: "timezone",
      baseName: "timezone",
      type: "string",
    },
    {
      name: "owner",
      baseName: "owner",
      type: "string",
    },
    {
      name: "ownerEmail",
      baseName: "owner_email",
      type: "string",
    },
    {
      name: "successCount",
      baseName: "success_count",
      type: "number",
    },
    {
      name: "errorCount",
      baseName: "error_count",
      type: "number",
    },
    {
      name: "lastSuccess",
      baseName: "last_success",
      type: "Date",
    },
    {
      name: "lastError",
      baseName: "last_error",
      type: "Date",
    },
    {
      name: "disabled",
      baseName: "disabled",
      type: "boolean",
    },
    {
      name: "tags",
      baseName: "tags",
      type: "{ [key: string]: string; }",
    },
    {
      name: "retries",
      baseName: "retries",
      type: "number",
    },
    {
      name: "parentJob",
      baseName: "parent_job",
      type: "string",
    },
    {
      name: "dependentJobs",
      baseName: "dependent_jobs",
      type: "Array<string>",
    },
    {
      name: "processors",
      baseName: "processors",
      type: "Processors",
    },
    {
      name: "concurrency",
      baseName: "concurrency",
      type: "string",
    },
    {
      name: "executor",
      baseName: "executor",
      type: "string",
    },
    {
      name: "executorConfig",
      baseName: "executor_config",
      type: "ExecutorConfig",
    },
  ];

  static getAttributeTypeMap() {
    return Job.attributeTypeMap;
  }
}

/**
 * A member represents a cluster member node.
 */
export class Member {
  /**
   * Node name
   */
  "name"?: string;
  /**
   * IP Address
   */
  "addr"?: string;
  /**
   * Port number
   */
  "port"?: number;
  /**
   * Tags asociated with this node
   */
  "tags"?: { [key: string]: string };
  /**
   * The serf status of the node see: https://godoc.org/github.com/hashicorp/serf/serf#MemberStatus
   */
  "status"?: number;
  /**
   * Serf protocol minimum version this node can understand or speak
   */
  "protocolMin"?: number;
  /**
   * Serf protocol maximum version this node can understand or speak
   */
  "protocolMax"?: number;
  /**
   * Serf protocol current version this node can understand or speak
   */
  "protocolCur"?: number;
  /**
   * Serf delegate protocol minimum version this node can understand or speak
   */
  "delegateMin"?: number;
  /**
   * Serf delegate protocol maximum version this node can understand or speak
   */
  "delegateMax"?: number;
  /**
   * Serf delegate protocol current version this node can understand or speak
   */
  "delegateCur"?: number;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "name",
      baseName: "Name",
      type: "string",
    },
    {
      name: "addr",
      baseName: "Addr",
      type: "string",
    },
    {
      name: "port",
      baseName: "Port",
      type: "number",
    },
    {
      name: "tags",
      baseName: "Tags",
      type: "{ [key: string]: string; }",
    },
    {
      name: "status",
      baseName: "Status",
      type: "number",
    },
    {
      name: "protocolMin",
      baseName: "ProtocolMin",
      type: "number",
    },
    {
      name: "protocolMax",
      baseName: "ProtocolMax",
      type: "number",
    },
    {
      name: "protocolCur",
      baseName: "ProtocolCur",
      type: "number",
    },
    {
      name: "delegateMin",
      baseName: "DelegateMin",
      type: "number",
    },
    {
      name: "delegateMax",
      baseName: "DelegateMax",
      type: "number",
    },
    {
      name: "delegateCur",
      baseName: "DelegateCur",
      type: "number",
    },
  ];

  static getAttributeTypeMap() {
    return Member.attributeTypeMap;
  }
}

/**
 * Processor plugins used to process executions results of this job
 */
export class Processors extends null<String, Map> {
  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [];

  static getAttributeTypeMap() {
    return super.getAttributeTypeMap().concat(Processors.attributeTypeMap);
  }
}

/**
 * Status represents details about the node.
 */
export class Status {
  /**
   * Node basic details
   */
  "agent"?: any;
  /**
   * Serf status
   */
  "serf"?: any;
  /**
   * Tags asociated with this node
   */
  "tags"?: any;

  static discriminator: string | undefined = undefined;

  static attributeTypeMap: Array<{
    name: string;
    baseName: string;
    type: string;
  }> = [
    {
      name: "agent",
      baseName: "agent",
      type: "any",
    },
    {
      name: "serf",
      baseName: "serf",
      type: "any",
    },
    {
      name: "tags",
      baseName: "tags",
      type: "any",
    },
  ];

  static getAttributeTypeMap() {
    return Status.attributeTypeMap;
  }
}

let enumsMap: { [index: string]: any } = {};

let typeMap: { [index: string]: any } = {
  Execution: Execution,
  ExecutorConfig: ExecutorConfig,
  Job: Job,
  Member: Member,
  Processors: Processors,
  Status: Status,
};

export interface Authentication {
  /**
   * Apply authentication settings to header and query params.
   */
  applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
  public username: string = "";
  public password: string = "";

  applyToRequest(requestOptions: localVarRequest.Options): void {
    requestOptions.auth = {
      username: this.username,
      password: this.password,
    };
  }
}

export class ApiKeyAuth implements Authentication {
  public apiKey: string = "";

  constructor(private location: string, private paramName: string) {}

  applyToRequest(requestOptions: localVarRequest.Options): void {
    if (this.location == "query") {
      (<any>requestOptions.qs)[this.paramName] = this.apiKey;
    } else if (
      this.location == "header" &&
      requestOptions &&
      requestOptions.headers
    ) {
      requestOptions.headers[this.paramName] = this.apiKey;
    }
  }
}

export class OAuth implements Authentication {
  public accessToken: string = "";

  applyToRequest(requestOptions: localVarRequest.Options): void {
    if (requestOptions && requestOptions.headers) {
      requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
    }
  }
}

export class VoidAuth implements Authentication {
  public username: string = "";
  public password: string = "";

  applyToRequest(_: localVarRequest.Options): void {
    // Do nothing
  }
}

export enum DefaultApiApiKeys {}

export class DefaultApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: DefaultApiApiKeys, value: string) {
    (this.authentications as any)[DefaultApiApiKeys[key]].apiKey = value;
  }
  /**
   * List leader of cluster.
   * @param {*} [options] Override http request options.
   */
  public getLeader(
    options: any = {}
  ): Promise<{ response: localVarRequest.Response; body: Member }> {
    const localVarPath = this.basePath + "/leader";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: localVarRequest.Response; body: Member }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Member");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Force the node to leave the cluster.
   * @param {*} [options] Override http request options.
   */
  public leave(
    options: any = {}
  ): Promise<{ response: localVarRequest.Response; body: Array<Member> }> {
    const localVarPath = this.basePath + "/leave";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: localVarRequest.Response;
      body: Array<Member>;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "Array<Member>");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Gets `Status` object.
   * @param {*} [options] Override http request options.
   */
  public status(
    options: any = {}
  ): Promise<{ response: localVarRequest.Response; body: Status }> {
    const localVarPath = this.basePath + "/";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: localVarRequest.Response; body: Status }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Status");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum ExecutionsApiApiKeys {}

export class ExecutionsApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: ExecutionsApiApiKeys, value: string) {
    (this.authentications as any)[ExecutionsApiApiKeys[key]].apiKey = value;
  }
  /**
   * List executions.
   * @param jobName The job that owns the executions to be fetched.
   * @param {*} [options] Override http request options.
   */
  public listExecutionsByJob(
    jobName: string,
    options: any = {}
  ): Promise<{ response: localVarRequest.Response; body: Array<Execution> }> {
    const localVarPath =
      this.basePath +
      "/jobs/{job_name}/executions".replace(
        "{" + "job_name" + "}",
        encodeURIComponent(String(jobName))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'jobName' is not null or undefined
    if (jobName === null || jobName === undefined) {
      throw new Error(
        "Required parameter jobName was null or undefined when calling listExecutionsByJob."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: localVarRequest.Response;
      body: Array<Execution>;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "Array<Execution>");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
export enum JobsApiApiKeys {}

export class JobsApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: JobsApiApiKeys, value: string) {
    (this.authentications as any)[JobsApiApiKeys[key]].apiKey = value;
  }
  /**
   * Create or updates a new job.
   * @param body Updated job object
   * @param {*} [options] Override http request options.
   */
  public createOrUpdateJob(
    body: Job,
    options: any = {}
  ): Promise<{ response: localVarRequest.Response; body: Job }> {
    const localVarPath = this.basePath + "/jobs";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'body' is not null or undefined
    if (body === null || body === undefined) {
      throw new Error(
        "Required parameter body was null or undefined when calling createOrUpdateJob."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(body, "Job"),
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: localVarRequest.Response; body: Job }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Job");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Delete a job.
   * @param jobName The job that needs to be deleted.
   * @param {*} [options] Override http request options.
   */
  public deleteJob(
    jobName: string,
    options: any = {}
  ): Promise<{ response: localVarRequest.Response; body: Job }> {
    const localVarPath =
      this.basePath +
      "/jobs/{job_name}".replace(
        "{" + "job_name" + "}",
        encodeURIComponent(String(jobName))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'jobName' is not null or undefined
    if (jobName === null || jobName === undefined) {
      throw new Error(
        "Required parameter jobName was null or undefined when calling deleteJob."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: localVarRequest.Response; body: Job }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Job");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * List jobs.
   * @param tags Filter jobs by tags
   * @param {*} [options] Override http request options.
   */
  public getJobs(
    tags?: Array<string>,
    options: any = {}
  ): Promise<{ response: localVarRequest.Response; body: Array<Job> }> {
    const localVarPath = this.basePath + "/jobs";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    if (tags !== undefined) {
      localVarQueryParameters["tags"] = ObjectSerializer.serialize(
        tags,
        "Array<string>"
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: localVarRequest.Response;
      body: Array<Job>;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "Array<Job>");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
  /**
   * Executes a job.
   * @param jobName The job that needs to be run.
   * @param {*} [options] Override http request options.
   */
  public runJob(
    jobName: string,
    options: any = {}
  ): Promise<{ response: localVarRequest.Response; body: Job }> {
    const localVarPath =
      this.basePath +
      "/jobs/{job_name}".replace(
        "{" + "job_name" + "}",
        encodeURIComponent(String(jobName))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'jobName' is not null or undefined
    if (jobName === null || jobName === undefined) {
      throw new Error(
        "Required parameter jobName was null or undefined when calling runJob."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: localVarRequest.Response; body: Job }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Job");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Show a job.
   * @param jobName The job that needs to be fetched.
   * @param {*} [options] Override http request options.
   */
  public showJobByName(
    jobName: string,
    options: any = {}
  ): Promise<{ response: localVarRequest.Response; body: Job }> {
    const localVarPath =
      this.basePath +
      "/jobs/{job_name}".replace(
        "{" + "job_name" + "}",
        encodeURIComponent(String(jobName))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'jobName' is not null or undefined
    if (jobName === null || jobName === undefined) {
      throw new Error(
        "Required parameter jobName was null or undefined when calling showJobByName."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: localVarRequest.Response; body: Job }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Job");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
  /**
   * Toggle a job.
   * @param jobName The job that needs to be toggled.
   * @param {*} [options] Override http request options.
   */
  public toggleJob(
    jobName: string,
    options: any = {}
  ): Promise<{ response: localVarRequest.Response; body: Job }> {
    const localVarPath =
      this.basePath +
      "/jobs/{job_name}/toggle".replace(
        "{" + "job_name" + "}",
        encodeURIComponent(String(jobName))
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    // verify required parameter 'jobName' is not null or undefined
    if (jobName === null || jobName === undefined) {
      throw new Error(
        "Required parameter jobName was null or undefined when calling toggleJob."
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{ response: localVarRequest.Response; body: Job }>(
      (resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            body = ObjectSerializer.deserialize(body, "Job");
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              resolve({ response: response, body: body });
            } else {
              reject({ response: response, body: body });
            }
          }
        });
      }
    );
  }
}
export enum MembersApiApiKeys {}

export class MembersApi {
  protected _basePath = defaultBasePath;
  protected defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
  };

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: MembersApiApiKeys, value: string) {
    (this.authentications as any)[MembersApiApiKeys[key]].apiKey = value;
  }
  /**
   * List members.
   * @param {*} [options] Override http request options.
   */
  public getMember(
    options: any = {}
  ): Promise<{ response: localVarRequest.Response; body: Array<Member> }> {
    const localVarPath = this.basePath + "/members";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this.defaultHeaders
    );
    let localVarFormParams: any = {};

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    this.authentications.default.applyToRequest(localVarRequestOptions);

    if (Object.keys(localVarFormParams).length) {
      if (localVarUseFormData) {
        (<any>localVarRequestOptions).formData = localVarFormParams;
      } else {
        localVarRequestOptions.form = localVarFormParams;
      }
    }
    return new Promise<{
      response: localVarRequest.Response;
      body: Array<Member>;
    }>((resolve, reject) => {
      localVarRequest(localVarRequestOptions, (error, response, body) => {
        if (error) {
          reject(error);
        } else {
          body = ObjectSerializer.deserialize(body, "Array<Member>");
          if (
            response.statusCode &&
            response.statusCode >= 200 &&
            response.statusCode <= 299
          ) {
            resolve({ response: response, body: body });
          } else {
            reject({ response: response, body: body });
          }
        }
      });
    });
  }
}
